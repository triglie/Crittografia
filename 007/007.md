# Teoria dei numeri computazionale

[TOC]

## I gruppi di base

Poniamo $\Z = \{. . . , -2, -1, 0, 1, 2, . . .\}$ che denota l'insieme di interi. Poniamo $\Z_+ = \{1, 2, ...\}$ che denota l'insieme degli interi positivi e $\N = \{0, 1, 2, ...\}$ l'insieme degli interi non negativi.



### Interi mod N

Se $a, b$ sono interi, non entrambi zero, allora il loro massimo comun divisore, indicato con $MCD(a, b)$, è il più grande intero $d$ tale che $d$ divide $a$ e $d$ divide $b$. Se $MCD(a, b) = 1$ allora diciamo che $a$ e $b$ sono primi tra loro. Se considero $a$ ed $N$ sono interi con $N > 0$ allora ci sono interi unici $r$, $q$ tali che $a = N q + r$ e $0 ≤ r < N$. Chiamiamo $r$ il resto della divisione di $a$ per $N$ , e lo indichiamo con $\mod N$. Notiamo che l'operazione $a \mod N$ è deﬁnita sia per valori negativi che non negativi di $a$, ma solo per valori positivi di $N$. (Quando $a$ è negativo, anche il quoziente $q$ sarà negativo, ma il resto $r$ deve essere sempre compreso nell'intervallo indicato $0 ≤ r < N$). Se $a, b$ sono interi qualsiasi e $N$ è un intero positivo, scriviamo $a \equiv b\space (mod \space N)$ se $a \space mod \space N = b \space mod \space N$. Associamo a qualsiasi intero positivo $N$ i seguenti due insiemi:
$$
\Z_N = \{0,1,...,N-1\} \\
\Z^*_N = \{i \in \Z : 1 \le i \le N-1 \and MCD(i,N) = 1\}
$$
Il primo insieme è detto **insieme di interi mod N**. La sua dimensione è $N$ , e contiene esattamente gli interi che sono possibili valori di un *mod N* come intervalli su $\Z$. Definiamo la funzione di **Eulero Phi** $ϕ: \Z_+ → \N$ per $ϕ(N ) = |\Z^∗_N|$ per ogni $N ∈ \Z_+$ . Cioè, $\phi(N)$ è la dimensione dell'insieme $\Z^∗_N$.



### Gruppi

Sia $G$ un insieme non vuoto, e sia $·$ un'operazione binaria su $G$. Ciò significa che per ogni due punti $a, b ∈ G$, viene definito un valore $a · b$.

**Definizione 1.1**	Sia G un insieme non vuoto e sia $·$ indichiamo un'operazione binaria su $G$. Diciamo che $G$ è un gruppo se ha le seguenti proprietà:

1. **Chiusura**: Per ogni $a, b ∈ G$ è il caso che anche $a · b$ sia in $G$.
2. **Associatività**: Per ogni $a, b, c ∈ G$ è il caso che $(a · b) · c = a · (b · c)$.
3. **Identità**: esiste un elemento $1 ∈ G$ tale che $a · 1 = 1 · a = a$ per ogni $a ∈ G$.
4. **Invertibilità**: Per ogni $a ∈ G$ esiste un unico $b ∈ G$ tale che $a · b = b · a = 1$.

L'elemento $b$ nella condizione di invertibilità è indicato come l'inverso dell'elemento $a$, ed è
denotato $a^{-1}$ .

Torniamo ora agli insiemi che abbiamo definito sopra e facciamo un'osservazione sulla loro struttura di gruppo. Sia $N$ un intero positivo. L'operazione di addizione modulo $N$ prende in ingresso due qualsiasi interi $a, b$ e restituisce $(a + b)\mod N$ . L'operazione di moltiplicazione modulo $N$ prende in input due interi qualsiasi $a, b$ e restituisce $a \cdot b\mod N$.

**Proposizione 1.2 (Algoritmo di divisione)**	Se $a,b \in \Z$, $b \neq 0$, allora esistono $q, r \in Z$ (quoziente e resto) tali che $a = bq + r$ con $0 \le r \le |b|$.

DIMOSTRAZIONE.	Supponiamo dapprima che $a \ge 0$ e procediamo per induzione su $a$. Per $a = 0$ la proprietà è vera, basta prendere $q = r = 0$. Supposta vera la proprietà per $a$, cioè supponiamo che $a = bq + r$ con $0 \le r \le |b|$ e proviamola per $a + 1$. Ma da $a = bq + r$ abbiamo $a + 1 = bq + r + 1$; per cui se $r + 1 \lt |b$ la proprietà è vera per $a + 1$; se invece $r + 1 = |b|$, cioè $r + 1 = ±b$ allora avremo $a +1 = b(q±1) + 0$ ed anche in tal caso la proprietà è vera per $a + 1$. Così per l'ipotesi induttiva l'algoritmo di divisione è vero per ogni $a$ naturale. Infine, se $a \lt 0$ la proprietà sarà vera per $-a$ e quindi $-a = bq + r$ con $0 \le r \lt |b|$. Allora $a = b(−q) − r$, per cui se $r = 0$ abbiamo la tesi, se invece $r > 0$, scriveremo $a = b(−q) − |b| + |b| − r$, cioè $a = b(−q ± 1) + r'$ con $r' = |b| − r < |b|$.

Quoziente e resto sono unici.

**Preposizione 1.3 (Algoritmo Euclideo)**	Siano $a,b \in \Z$, $b \neq 0$, consideriamo le seguenti divisioni successive.
$$
a = bq_1 + r_1, \mbox{ con } 0 ≤ r_1 < |b|, \mbox{ e se } r_1 \neq 0,\\
b = r_1 q_2 + r_2, \mbox{ con } 0 ≤ r_2 < r_1, \mbox{ e se } r_2 \neq 0,\\
r_1 = r_2 q_3 + r_3, \mbox{ con } 0 ≤ r_3 < r_2, \mbox{ e se } r_3 \neq 0,\\
... \space ... \space ...\\
r_{n−2} = r_{n−1} q_n + r_n, \mbox{ con } 0 ≤ r_n < r_{n−1}, \mbox{ e se } r_n \neq 0,\\
r_{n−1} = r_n q_{n+1};
$$
Allora $r_n$ (ultimo resto non nullo) è il cercato massimo comune divisore.

DIMOSTRAZIONE.	Euclide osservò che tale procedura ha termine in quanto $r_1 < |b|$, $r_2 < r_1$ , ecc. per cui dopo al più $b$ divisioni successive il resto deve essere $0$. Per provare che tale $r_n$ è il $MCD(a, b)$ cominciamo ad osservare che dall’ultima eguaglianza segue $r_n|r_{n−1}$; dalla penultima segue che $r_n|r_{n−2}$; così risalendo dalla terza deduco $r_n|r_1$, dalla seconda $r_n||b|$ ed infine dalla prima $r_n|a$. In definitiva, $r_n$ soddisfa la prima condizione richiesta dal $MCD(a, b)$.
D’altra parte, se $d$ è un divisore comune ad $a$ e $b$ dalla prima divisione deduciamo che $d|r_1$, quindi dalla seconda deduciamo $d|r_2$ e dalla terza $d|r_3$, così continuando quando arriveremo all’ultima divisione troveremo che $d|r_n$ e la seconda condizione per il $MCD(a, b)$ resta verificata. Per cui $r_n = MCD(a, b)$.

**Preposizione 1.4 (Identità di Bézout)**	Se $d = MCD(a, b)$ allora si possono trovare $\lambda$ e $\mu$ in $\Z$ tali che $d = \lambda a + \mu b$.

DIMOSTRAZIONE.	Basta utilizzare le divisioni successive dell'algoritmo euclideo partendo dall'ultima e risalendo sino alla prima.

**Esempio**

$MCD(750, 72)$
$$
750 = −72 · (−10) + 30,\\
−72 = 30 · (−3) + 18,\\
30 = 18 · 1 + 12,\\
18 = 12 · 1 + 6\\
12 = 6 · 2
$$
L'identità di Bézout è la seguente:
$$
6 = 18 − 1 · 12,\\
6 = 18 − [30 − 1 · 18] = 2 · 18 − 30,\\
6 = 2 · [−72 + 3 · 30] − 30 = 2 · (−72) + 5 · 30,\\
6 = 2 · (−72) + 5 · [750 + 10 · (−72)] = 5 · 750 + 52 · (−72),\\
6 = 5 · 750 + 52 · (−72).
$$
Per cui si ha $\lambda = 5$ e $\mu = 52$. 

**Osservazione 1.5**	Sia $N$ un intero positivo. Allora $\Z_N$ è un gruppo sotto addizione modulo $N$ e $\Z^∗_N$ è un gruppo sotto moltiplicazione modulo $N$.

In $\Z_N$, l'elemento identità è $0$ e l'inverso di $a$ è $−a \mod N = N − a$. In $\Z^∗_N$, l'elemento identità è $1$ e l'inverso di $a$ è $a \cdot b ∈ \Z^∗_N$ tale che $ab ≡ 1 \space (mod \space N)$. Questa cosa è vera perché ci si restringe alle classi i cui rappresentanti sono coprimi con $N$, per dimostrare tale proprietà è necessaria l'**identità di Bézout**: se $a$ è coprimo con $N$, esistono due interi $x, y$ tali che:
$$
ax + Ny = 1 \\
ax \equiv 1 \mod N
$$


In qualsiasi gruppo, possiamo deﬁnire un'operazione di elevazione a potenza che associa a qualsiasi $a ∈ G$ e a qualsiasi intero $i$ un elemento di gruppo che denotiamo $a^i$, deﬁnito come segue. Se $i = 0$ allora $a^i$ è definito come $1$, l'elemento di identità del gruppo. Se $i > 0$ allora:
$$
a^i = a · a · ... · a \mbox{ ripetuto i-volte}
$$
Se $i$ è negativo, allora possiamo definire $a^i = (a^{-1})^j$, con $j = |-i|$, per cui si ha:
$$
a^i = a^{-1} · a^{-1} · ... · a^{-1} \mbox{ ripetuto j-volte}
$$
Con queste definizioni in atto, possiamo manipolare gli esponenti nel modo in cui siamo abituati con i numeri ordinari.

È consuetudine nella teoria dei gruppi chiamare la dimensione di un gruppo $G$ il suo ordine. Cioè, l'ordine di un gruppo $G$ è $|G|$, il numero di elementi in esso. Utilizzeremo spesso il seguente fatto di base.
Se un qualsiasi elemento di gruppo viene elevato all'ordine del gruppo, il risultato è l'elemento identità del gruppo.

**Osservazione 1.6**	Sia $G$ un gruppo e sia $m = |G|$ il suo ordine. Allora $a^m = 1 \space \forall a \in G$.

Ciò significa che il calcolo negli indici di gruppo può essere eseguito modulo $m$:

**Preposizione 1.7**	Sia $G$ un gruppo e sia $m = |G|$ il suo ordine. Allora $a^i = a^{i \mod m} \space \forall a \in G \and \forall i \in \Z$. 

DIMOSTRAZIONE.	La dimostrazione di tale preposizione segue dall'Osservazione 1.6.

Poniamo $0 \le i \lt m$ in questo caso si ha che $a^i = a^{i \mod m}$ è sempre vera.
Poniamo $i = m$ in questo caso si ha che $a^m = a^{m \mod m} = 1$ e anche in questo caso la proprietà resta vera.
Poniamo $i \ge m$ in questo caso procediamo per induzione, per $i = m$ abbiamo già visto che la proprietà è vera, quindi consideriamo $i = m+1$ per cui si ha $a^{m + 1} = a^{m+1 \mod m}$ da cui segue $a^{m}a = a^{m \mod m}a \rightarrow a = a$, per cui continua a valere la proprietà.
Poniamo $i \le 0$ in questo caso procediamo per induzione, per $i = 0$ abbiamo già visto che la proprietà è vera, quindi consideriamo $i = -1$ per cui si ha $a^{-1} = a^{-1 \mod m}$ da cui segue $a^{-1} = a^{m - 1} \rightarrow a^{-1} = a^{-1}$, per continua a valere la proprietà.



Se $G$ è un gruppo, un insieme $S ⊆ G$ è detto sottogruppo se è un gruppo a sé stante, sotto la stessa operazione di quella per cui $G$ è un gruppo. Se sappiamo già che $G$ è un gruppo, c'è un modo semplice per verificare se $S$ è un sottogruppo: se e solo se $x · y^{−1} ∈ S$ per ogni $x, y ∈ S$. Qui $y^{−1}$ è l'inverso di $y$ in $G$.

**Osservazione 1.8**	Sia $G$ un gruppo e sia $S$ un sottogruppo di $G$. Allora l'ordine di $S$ divide l'ordine di $G$.



## Algoritmi

Normalmente ignoriamo il costo delle operazioni di base (ad es. addizioni e moltiplicazioni). Con numeri "crittografici" tali costi non possono essere ignorati.

- $a \mod N$ costa $O(|a||N|)$;
- sommare due interi di $k$ bit richiede $O(k)$ operazioni binarie;
- moltiplicare due interi di $k$ bit richiede $O(k^2)$ operazioni binarie;
- calcolare $a^m \mod N$, $|N| = |a| = k$, costa $O(|m|k^2)$.



### Algoritmi di divisione intera e modulo

Definiamo la funzione di divisione tra interi prendendo in input due interi $a, N$, con $N > 0$, e restituendo il quoziente e il resto ottenuti dividendo $a$ per $N$. Cioè, la funzione restituisce $(q, r)$ tale che $a = qN + r$ con $0 ≤ r < N$. Indichiamo con ``INT-DIV`` un algoritmo che implementa questa funzione.
L'algoritmo utilizza il metodo di divisione standard che abbiamo imparato a scuola, che risulta essere eseguito in un tempo proporzionale al prodotto delle lunghezze binarie di $a$ e $N$.
Vogliamo anche un algoritmo che implementi la funzione $mod$, prendendo input interi $a, N$ con $N > 0$ e restituendo un $\mod N$. Questo algoritmo, denominato ``MOD``, può essere implementato semplicemente chiamando ``INT-DIV(a, N)`` per ottenere $(q, r)$, e quindi restituendo solo il resto $r$.



### Algoritmo di Euclide esteso

In aritmetica e nella programmazione l'algoritmo esteso di Euclide è un'estensione dell'algoritmo di Euclide che calcola non solo il massimo comun divisore tra due numeri $a, b$, ma anche i coefficienti dell'identità di Bézout.

Supponiamo che $a, b$ siano interi, entrambi non nulli. Un fatto fondamentale sul massimo comun divisore di $a$ e $b$ è che è il più piccolo elemento positivo dell'insieme di tutte le combinazioni lineari intere di $a$ e $b$.
$$
\{\lambda a + \mu b: \lambda, \mu \in \Z\}
$$
In particolare, se $d = MCD(a, b)$ allora esistono interi $\lambda, \mu$ tali che $d = \lambda a + \mu b$. (Nota che $\lambda$ o $\mu$ potrebbero essere negativi).

Oltre al MCD stesso, troveremo utile poter calcolare questi pesi $\lambda, \mu$. Questo è ciò che fa l'algoritmo di Euclide esteso ``EXT-GCD``: dati $a, b$ come input, restituisce $(d, \lambda, \mu)$ tale che $d = MCD(a, b) = \lambda a + \mu b$. L'algoritmo stesso è un'estensione del classico algoritmo di Euclide per il calcolo del MCD e la descrizione più semplice è ricorsiva. Ora lo forniamo e poi ne discutiamo la correttezza e il tempo di esecuzione. L'algoritmo accetta in input qualsiasi numero intero $a, b$, entrambi non nulli.

```pseudocode
EXT-GCD(a, b):
	if (b == 0) then return (a, 1, 0)
	else
		(q, r) <- INT-DIV(a, b)
		(d, x, y) <- EXT-GCD(b, r)
		lambda <- y
		mu <- x - qy
		return (d, lambda, mu)
```

Il caso base è quando $b = 0$. Se $b = 0$ allora sappiamo per assunzione che $a \neq 0$, quindi $MCD(a, b) = a$, e poiché $a = a(1) + b(0)$, i pesi sono 1 e 0. Se $b \neq 0$ allora possiamo dividere per esso, e dividiamo $a$ per esso per ottenere un quoziente $q$ e il resto $r$. Per la ricorsione usiamo il fatto che $MCD(a, b) = MCD(b, r)$. La chiamata ricorsiva produce quindi $d = MCD(a, b)$ insieme ai pesi $x, y$ tali che $d = bx + ry$. Notando che $a = bq + r$ abbiamo la conferma che i valori assegnati ad $\lambda, \mu$ sono corretti.
$$
d = bx + ry = bx + (a - bq)y = ay + b(x - qy) = a \lambda + n \mu
$$
Il tempo di esecuzione di questo algoritmo è $O(|a| · |b|)$.



### Algoritmo per l'inverso modulare

Serve per il calcolo dell'inverso moltiplicativo di $a$ nel gruppo $\Z^∗_N$. Ovvero, su input $N > 0$ e $a ∈ \Z^∗_N$, l'algoritmo ``MOD-INV`` restituisce $b$ tale che $a \cdot b ≡ 1 \space (mod \space N)$. Il metodo è abbastanza semplice:

```pseudocode
MOD-INV(a, N):
	(d, x, y) <- EXT-GCD(a, N)
	b <- x mod N
	return b
```

Poiché $a ∈ \Z^∗_N$ sappiamo che $MCD(a, N) = 1$. L'algoritmo ``EXT-GCD`` garantisce quindi che $d = 1$ e $1 = ax + Ny$. Poiché $N \mod N = 0$, abbiamo $ax ≡ 1 \mod N$, e quindi $b = x \mod N$ è il valore giusto da restituire. Il costo di tale procedura è $O(|a|·|N|)$.



### Teorema Cinese del resto (CRT)

È un metodo per risolvere un certo tipo di congruenze.

Siano $m_1, ..., m_n$ coprimi e $a_1, ..., a_n$ tali che:
$$
x = a_1 \mod m_1 \\
...\\
x = a_n \mod m_n
$$
Il teorema cinese del resto ci assicura che tale sistema ha un'unica soluzione modulo $M = m_1, ..., m_n$ e ci dice come calcolarla.

Tale soluzione è:
$$
x = \sum_{i = 1}^{n} a_iM_iy_i \mod M
$$
dove $M_i = \frac{M}{m_i}$ e $y_i = M_i^{-1} \mod m_i$ 

**10 Slide 20 e pag. 186**